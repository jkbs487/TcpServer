// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#include "IM.BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace IM {
namespace BaseDefine {
constexpr IpAddr::IpAddr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0u){}
struct IpAddrDefaultTypeInternal {
  constexpr IpAddrDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpAddrDefaultTypeInternal() {}
  union {
    IpAddr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpAddrDefaultTypeInternal _IpAddr_default_instance_;
constexpr UserInfo::UserInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_nick_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatar_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_real_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_tel_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_domain_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sign_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , user_gender_(0u)
  , department_id_(0u)
  , status_(0u){}
struct UserInfoDefaultTypeInternal {
  constexpr UserInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserInfoDefaultTypeInternal _UserInfo_default_instance_;
constexpr ContactSessionInfo::ContactSessionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : latest_msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , session_id_(0u)
  , session_status_(0)

  , updated_time_(0u)
  , latest_msg_id_(0u)
  , latest_msg_from_user_id_(0u)
  , session_type_(1)

  , latest_msg_type_(1)
{}
struct ContactSessionInfoDefaultTypeInternal {
  constexpr ContactSessionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ContactSessionInfoDefaultTypeInternal() {}
  union {
    ContactSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
constexpr UserStat::UserStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , status_(1)
{}
struct UserStatDefaultTypeInternal {
  constexpr UserStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserStatDefaultTypeInternal() {}
  union {
    UserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserStatDefaultTypeInternal _UserStat_default_instance_;
constexpr ServerUserStat::ServerUserStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , status_(1)

  , client_type_(1)
{}
struct ServerUserStatDefaultTypeInternal {
  constexpr ServerUserStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServerUserStatDefaultTypeInternal() {}
  union {
    ServerUserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
constexpr UnreadInfo::UnreadInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : latest_msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , session_id_(0u)
  , unread_cnt_(0u)
  , latest_msg_id_(0u)
  , latest_msg_from_user_id_(0u)
  , session_type_(1)

  , latest_msg_type_(1)
{}
struct UnreadInfoDefaultTypeInternal {
  constexpr UnreadInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UnreadInfoDefaultTypeInternal() {}
  union {
    UnreadInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
constexpr MsgInfo::MsgInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , msg_id_(0u)
  , from_session_id_(0u)
  , create_time_(0u)
  , msg_type_(1)
{}
struct MsgInfoDefaultTypeInternal {
  constexpr MsgInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MsgInfoDefaultTypeInternal() {}
  union {
    MsgInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
constexpr GroupVersionInfo::GroupVersionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : group_id_(0u)
  , version_(0u){}
struct GroupVersionInfoDefaultTypeInternal {
  constexpr GroupVersionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GroupVersionInfoDefaultTypeInternal() {}
  union {
    GroupVersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
constexpr GroupInfo::GroupInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : group_member_list_()
  , group_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , group_avatar_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , group_id_(0u)
  , version_(0u)
  , group_creator_id_(0u)
  , shield_status_(0u)
  , group_type_(1)
{}
struct GroupInfoDefaultTypeInternal {
  constexpr GroupInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GroupInfoDefaultTypeInternal() {}
  union {
    GroupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
constexpr UserTokenInfo::UserTokenInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , push_count_(0u)
  , push_type_(0u)
  , user_type_(1)
{}
struct UserTokenInfoDefaultTypeInternal {
  constexpr UserTokenInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserTokenInfoDefaultTypeInternal() {}
  union {
    UserTokenInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
constexpr PushResult::PushResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , result_code_(0u){}
struct PushResultDefaultTypeInternal {
  constexpr PushResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PushResultDefaultTypeInternal() {}
  union {
    PushResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PushResultDefaultTypeInternal _PushResult_default_instance_;
constexpr ShieldStatus::ShieldStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , group_id_(0u)
  , shield_status_(0u){}
struct ShieldStatusDefaultTypeInternal {
  constexpr ShieldStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ShieldStatusDefaultTypeInternal() {}
  union {
    ShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
constexpr OfflineFileInfo::OfflineFileInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : task_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , from_user_id_(0u)
  , file_size_(0u){}
struct OfflineFileInfoDefaultTypeInternal {
  constexpr OfflineFileInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OfflineFileInfoDefaultTypeInternal() {}
  union {
    OfflineFileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
constexpr DepartInfo::DepartInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dept_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dept_id_(0u)
  , priority_(0u)
  , parent_dept_id_(0u)
  , dept_status_(0)
{}
struct DepartInfoDefaultTypeInternal {
  constexpr DepartInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DepartInfoDefaultTypeInternal() {}
  union {
    DepartInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
constexpr PushShieldStatus::PushShieldStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , shield_status_(0u){}
struct PushShieldStatusDefaultTypeInternal {
  constexpr PushShieldStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PushShieldStatusDefaultTypeInternal() {}
  union {
    PushShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PushShieldStatusDefaultTypeInternal _PushShieldStatus_default_instance_;
}  // namespace BaseDefine
}  // namespace IM
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_IM_2eBaseDefine_2eproto[15];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_IM_2eBaseDefine_2eproto[23];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_IM_2eBaseDefine_2eproto = nullptr;

const uint32_t TableStruct_IM_2eBaseDefine_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::IpAddr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::IpAddr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::IpAddr, ip_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::IpAddr, port_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_gender_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_nick_name_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, avatar_url_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, department_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, email_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_real_name_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_tel_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, user_domain_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, status_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserInfo, sign_info_),
  7,
  8,
  0,
  1,
  9,
  2,
  3,
  4,
  5,
  10,
  6,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, session_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, session_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, session_status_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, updated_time_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, latest_msg_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, latest_msg_data_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, latest_msg_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ContactSessionInfo, latest_msg_from_user_id_),
  1,
  6,
  2,
  3,
  4,
  0,
  7,
  5,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserStat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserStat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserStat, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserStat, status_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ServerUserStat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ServerUserStat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ServerUserStat, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ServerUserStat, status_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ServerUserStat, client_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, session_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, session_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, unread_cnt_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, latest_msg_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, latest_msg_data_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, latest_msg_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UnreadInfo, latest_msg_from_user_id_),
  1,
  5,
  2,
  3,
  0,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, msg_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, from_session_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, create_time_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, msg_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::MsgInfo, msg_data_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupVersionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupVersionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupVersionInfo, group_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupVersionInfo, version_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, version_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_name_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_avatar_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_creator_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, shield_status_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::GroupInfo, group_member_list_),
  2,
  3,
  0,
  1,
  4,
  6,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, user_type_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, token_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, push_count_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::UserTokenInfo, push_type_),
  1,
  4,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushResult, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushResult, user_token_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushResult, result_code_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ShieldStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ShieldStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ShieldStatus, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ShieldStatus, group_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::ShieldStatus, shield_status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, from_user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, task_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, file_name_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::OfflineFileInfo, file_size_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, dept_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, priority_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, dept_name_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, parent_dept_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::DepartInfo, dept_status_),
  1,
  2,
  0,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushShieldStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushShieldStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushShieldStatus, user_id_),
  PROTOBUF_FIELD_OFFSET(::IM::BaseDefine::PushShieldStatus, shield_status_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::IM::BaseDefine::IpAddr)},
  { 10, 27, -1, sizeof(::IM::BaseDefine::UserInfo)},
  { 38, 52, -1, sizeof(::IM::BaseDefine::ContactSessionInfo)},
  { 60, 68, -1, sizeof(::IM::BaseDefine::UserStat)},
  { 70, 79, -1, sizeof(::IM::BaseDefine::ServerUserStat)},
  { 82, 95, -1, sizeof(::IM::BaseDefine::UnreadInfo)},
  { 102, 113, -1, sizeof(::IM::BaseDefine::MsgInfo)},
  { 118, 126, -1, sizeof(::IM::BaseDefine::GroupVersionInfo)},
  { 128, 142, -1, sizeof(::IM::BaseDefine::GroupInfo)},
  { 150, 161, -1, sizeof(::IM::BaseDefine::UserTokenInfo)},
  { 166, 174, -1, sizeof(::IM::BaseDefine::PushResult)},
  { 176, 185, -1, sizeof(::IM::BaseDefine::ShieldStatus)},
  { 188, 198, -1, sizeof(::IM::BaseDefine::OfflineFileInfo)},
  { 202, 213, -1, sizeof(::IM::BaseDefine::DepartInfo)},
  { 218, 226, -1, sizeof(::IM::BaseDefine::PushShieldStatus)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_IpAddr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_UserInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_ContactSessionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_UserStat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_ServerUserStat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_UnreadInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_MsgInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_GroupVersionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_GroupInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_UserTokenInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_PushResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_ShieldStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_OfflineFileInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_DepartInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::IM::BaseDefine::_PushShieldStatus_default_instance_),
};

const char descriptor_table_protodef_IM_2eBaseDefine_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023IM.BaseDefine.proto\022\rIM.BaseDefine\"\"\n\006"
  "IpAddr\022\n\n\002ip\030\001 \002(\t\022\014\n\004port\030\002 \002(\r\"\344\001\n\010Use"
  "rInfo\022\017\n\007user_id\030\001 \002(\r\022\023\n\013user_gender\030\002 "
  "\002(\r\022\026\n\016user_nick_name\030\003 \002(\t\022\022\n\navatar_ur"
  "l\030\004 \002(\t\022\025\n\rdepartment_id\030\005 \002(\r\022\r\n\005email\030"
  "\006 \002(\t\022\026\n\016user_real_name\030\007 \002(\t\022\020\n\010user_te"
  "l\030\010 \002(\t\022\023\n\013user_domain\030\t \002(\t\022\016\n\006status\030\n"
  " \002(\r\022\021\n\tsign_info\030\013 \001(\t\"\254\002\n\022ContactSessi"
  "onInfo\022\022\n\nsession_id\030\001 \002(\r\0220\n\014session_ty"
  "pe\030\002 \002(\0162\032.IM.BaseDefine.SessionType\0228\n\016"
  "session_status\030\003 \002(\0162 .IM.BaseDefine.Ses"
  "sionStatusType\022\024\n\014updated_time\030\004 \002(\r\022\025\n\r"
  "latest_msg_id\030\005 \002(\r\022\027\n\017latest_msg_data\030\006"
  " \002(\014\022/\n\017latest_msg_type\030\007 \002(\0162\026.IM.BaseD"
  "efine.MsgType\022\037\n\027latest_msg_from_user_id"
  "\030\010 \002(\r\"H\n\010UserStat\022\017\n\007user_id\030\001 \002(\r\022+\n\006s"
  "tatus\030\002 \002(\0162\033.IM.BaseDefine.UserStatType"
  "\"~\n\016ServerUserStat\022\017\n\007user_id\030\001 \002(\r\022+\n\006s"
  "tatus\030\002 \002(\0162\033.IM.BaseDefine.UserStatType"
  "\022.\n\013client_type\030\003 \002(\0162\031.IM.BaseDefine.Cl"
  "ientType\"\350\001\n\nUnreadInfo\022\022\n\nsession_id\030\001 "
  "\002(\r\0220\n\014session_type\030\002 \002(\0162\032.IM.BaseDefin"
  "e.SessionType\022\022\n\nunread_cnt\030\003 \002(\r\022\025\n\rlat"
  "est_msg_id\030\004 \002(\r\022\027\n\017latest_msg_data\030\005 \002("
  "\014\022/\n\017latest_msg_type\030\006 \002(\0162\026.IM.BaseDefi"
  "ne.MsgType\022\037\n\027latest_msg_from_user_id\030\007 "
  "\002(\r\"\203\001\n\007MsgInfo\022\016\n\006msg_id\030\001 \002(\r\022\027\n\017from_"
  "session_id\030\002 \002(\r\022\023\n\013create_time\030\003 \002(\r\022(\n"
  "\010msg_type\030\004 \002(\0162\026.IM.BaseDefine.MsgType\022"
  "\020\n\010msg_data\030\005 \002(\014\"5\n\020GroupVersionInfo\022\020\n"
  "\010group_id\030\001 \002(\r\022\017\n\007version\030\002 \002(\r\"\322\001\n\tGro"
  "upInfo\022\020\n\010group_id\030\001 \002(\r\022\017\n\007version\030\002 \002("
  "\r\022\022\n\ngroup_name\030\003 \002(\t\022\024\n\014group_avatar\030\004 "
  "\002(\t\022\030\n\020group_creator_id\030\005 \002(\r\022,\n\ngroup_t"
  "ype\030\006 \002(\0162\030.IM.BaseDefine.GroupType\022\025\n\rs"
  "hield_status\030\007 \002(\r\022\031\n\021group_member_list\030"
  "\010 \003(\r\"\204\001\n\rUserTokenInfo\022\017\n\007user_id\030\001 \002(\r"
  "\022,\n\tuser_type\030\002 \002(\0162\031.IM.BaseDefine.Clie"
  "ntType\022\r\n\005token\030\003 \002(\t\022\022\n\npush_count\030\004 \002("
  "\r\022\021\n\tpush_type\030\005 \002(\r\"5\n\nPushResult\022\022\n\nus"
  "er_token\030\001 \002(\t\022\023\n\013result_code\030\002 \002(\r\"H\n\014S"
  "hieldStatus\022\017\n\007user_id\030\001 \002(\r\022\020\n\010group_id"
  "\030\002 \002(\r\022\025\n\rshield_status\030\003 \002(\r\"^\n\017Offline"
  "FileInfo\022\024\n\014from_user_id\030\001 \002(\r\022\017\n\007task_i"
  "d\030\002 \002(\t\022\021\n\tfile_name\030\003 \002(\t\022\021\n\tfile_size\030"
  "\004 \002(\r\"\224\001\n\nDepartInfo\022\017\n\007dept_id\030\001 \002(\r\022\020\n"
  "\010priority\030\002 \002(\r\022\021\n\tdept_name\030\003 \002(\t\022\026\n\016pa"
  "rent_dept_id\030\004 \002(\r\0228\n\013dept_status\030\005 \002(\0162"
  "#.IM.BaseDefine.DepartmentStatusType\":\n\020"
  "PushShieldStatus\022\017\n\007user_id\030\001 \002(\r\022\025\n\rshi"
  "eld_status\030\002 \002(\r*\221\001\n\tServiceID\022\r\n\tSID_LO"
  "GIN\020\001\022\022\n\016SID_BUDDY_LIST\020\002\022\013\n\007SID_MSG\020\003\022\r"
  "\n\tSID_GROUP\020\004\022\014\n\010SID_FILE\020\005\022\026\n\022SID_SWITC"
  "H_SERVICE\020\006\022\r\n\tSID_OTHER\020\007\022\020\n\014SID_INTERN"
  "AL\020\010*\234\004\n\nLoginCmdID\022\034\n\027CID_LOGIN_REQ_MSG"
  "SERVER\020\201\002\022\034\n\027CID_LOGIN_RES_MSGSERVER\020\202\002\022"
  "\034\n\027CID_LOGIN_REQ_USERLOGIN\020\203\002\022\034\n\027CID_LOG"
  "IN_RES_USERLOGIN\020\204\002\022\033\n\026CID_LOGIN_REQ_LOG"
  "INOUT\020\205\002\022\033\n\026CID_LOGIN_RES_LOGINOUT\020\206\002\022\030\n"
  "\023CID_LOGIN_KICK_USER\020\207\002\022\036\n\031CID_LOGIN_REQ"
  "_DEVICETOKEN\020\210\002\022\036\n\031CID_LOGIN_RES_DEVICET"
  "OKEN\020\211\002\022\037\n\032CID_LOGIN_REQ_KICKPCCLIENT\020\212\002"
  "\022\037\n\032CID_LOGIN_RES_KICKPCCLIENT\020\213\002\022\036\n\031CID"
  "_LOGIN_REQ_PUSH_SHIELD\020\214\002\022\036\n\031CID_LOGIN_R"
  "ES_PUSH_SHIELD\020\215\002\022$\n\037CID_LOGIN_REQ_QUERY"
  "_PUSH_SHIELD\020\216\002\022$\n\037CID_LOGIN_RES_QUERY_P"
  "USH_SHIELD\020\217\002\022\031\n\024CID_LOGIN_REQ_REGIST\020\220\002"
  "\022\031\n\024CID_LOGIN_RES_REGIST\020\221\002*\222\007\n\016BuddyLis"
  "tCmdID\0222\n-CID_BUDDY_LIST_RECENT_CONTACT_"
  "SESSION_REQUEST\020\201\004\0223\n.CID_BUDDY_LIST_REC"
  "ENT_CONTACT_SESSION_RESPONSE\020\202\004\022!\n\034CID_B"
  "UDDY_LIST_STATUS_NOTIFY\020\203\004\022%\n CID_BUDDY_"
  "LIST_USER_INFO_REQUEST\020\204\004\022&\n!CID_BUDDY_L"
  "IST_USER_INFO_RESPONSE\020\205\004\022&\n!CID_BUDDY_L"
  "IST_REMOVE_SESSION_REQ\020\206\004\022&\n!CID_BUDDY_L"
  "IST_REMOVE_SESSION_RES\020\207\004\022$\n\037CID_BUDDY_L"
  "IST_ALL_USER_REQUEST\020\210\004\022%\n CID_BUDDY_LIS"
  "T_ALL_USER_RESPONSE\020\211\004\022(\n#CID_BUDDY_LIST"
  "_USERS_STATUS_REQUEST\020\212\004\022)\n$CID_BUDDY_LI"
  "ST_USERS_STATUS_RESPONSE\020\213\004\022)\n$CID_BUDDY"
  "_LIST_CHANGE_AVATAR_REQUEST\020\214\004\022*\n%CID_BU"
  "DDY_LIST_CHANGE_AVATAR_RESPONSE\020\215\004\022*\n%CI"
  "D_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY\020\216\004\022)"
  "\n$CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY\020\217"
  "\004\022&\n!CID_BUDDY_LIST_DEPARTMENT_REQUEST\020\220"
  "\004\022\'\n\"CID_BUDDY_LIST_DEPARTMENT_RESPONSE\020"
  "\221\004\022)\n$CID_BUDDY_LIST_AVATAR_CHANGED_NOTI"
  "FY\020\222\004\022,\n\'CID_BUDDY_LIST_CHANGE_SIGN_INFO"
  "_REQUEST\020\223\004\022-\n(CID_BUDDY_LIST_CHANGE_SIG"
  "N_INFO_RESPONSE\020\224\004\022,\n\'CID_BUDDY_LIST_SIG"
  "N_INFO_CHANGED_NOTIFY\020\225\004*\242\003\n\014MessageCmdI"
  "D\022\021\n\014CID_MSG_DATA\020\201\006\022\025\n\020CID_MSG_DATA_ACK"
  "\020\202\006\022\025\n\020CID_MSG_READ_ACK\020\203\006\022\030\n\023CID_MSG_RE"
  "AD_NOTIFY\020\204\006\022\031\n\024CID_MSG_TIME_REQUEST\020\205\006\022"
  "\032\n\025CID_MSG_TIME_RESPONSE\020\206\006\022\037\n\032CID_MSG_U"
  "NREAD_CNT_REQUEST\020\207\006\022 \n\033CID_MSG_UNREAD_C"
  "NT_RESPONSE\020\210\006\022\031\n\024CID_MSG_LIST_REQUEST\020\211"
  "\006\022\032\n\025CID_MSG_LIST_RESPONSE\020\212\006\022\"\n\035CID_MSG"
  "_GET_LATEST_MSG_ID_REQ\020\213\006\022\"\n\035CID_MSG_GET"
  "_LATEST_MSG_ID_RSP\020\214\006\022\036\n\031CID_MSG_GET_BY_"
  "MSG_ID_REQ\020\215\006\022\036\n\031CID_MSG_GET_BY_MSG_ID_R"
  "ES\020\216\006*\214\003\n\nGroupCmdID\022\"\n\035CID_GROUP_NORMAL"
  "_LIST_REQUEST\020\201\010\022#\n\036CID_GROUP_NORMAL_LIS"
  "T_RESPONSE\020\202\010\022\033\n\026CID_GROUP_INFO_REQUEST\020"
  "\203\010\022\034\n\027CID_GROUP_INFO_RESPONSE\020\204\010\022\035\n\030CID_"
  "GROUP_CREATE_REQUEST\020\205\010\022\036\n\031CID_GROUP_CRE"
  "ATE_RESPONSE\020\206\010\022$\n\037CID_GROUP_CHANGE_MEMB"
  "ER_REQUEST\020\207\010\022%\n CID_GROUP_CHANGE_MEMBER"
  "_RESPONSE\020\210\010\022#\n\036CID_GROUP_SHIELD_GROUP_R"
  "EQUEST\020\211\010\022$\n\037CID_GROUP_SHIELD_GROUP_RESP"
  "ONSE\020\212\010\022#\n\036CID_GROUP_CHANGE_MEMBER_NOTIF"
  "Y\020\213\010*\315\002\n\tFileCmdID\022\027\n\022CID_FILE_LOGIN_REQ"
  "\020\201\n\022\027\n\022CID_FILE_LOGIN_RES\020\202\n\022\023\n\016CID_FILE"
  "_STATE\020\203\n\022\033\n\026CID_FILE_PULL_DATA_REQ\020\204\n\022\033"
  "\n\026CID_FILE_PULL_DATA_RSP\020\205\n\022\025\n\020CID_FILE_"
  "REQUEST\020\206\n\022\026\n\021CID_FILE_RESPONSE\020\207\n\022\024\n\017CI"
  "D_FILE_NOTIFY\020\210\n\022\035\n\030CID_FILE_HAS_OFFLINE"
  "_REQ\020\211\n\022\035\n\030CID_FILE_HAS_OFFLINE_RES\020\212\n\022\035"
  "\n\030CID_FILE_ADD_OFFLINE_REQ\020\213\n\022\035\n\030CID_FIL"
  "E_DEL_OFFLINE_REQ\020\214\n*-\n\022SwitchServiceCmd"
  "ID\022\027\n\022CID_SWITCH_P2P_CMD\020\201\014*\265\005\n\nOtherCmd"
  "ID\022\030\n\023CID_OTHER_HEARTBEAT\020\201\016\022\037\n\032CID_OTHE"
  "R_STOP_RECV_PACKET\020\202\016\022\033\n\026CID_OTHER_VALID"
  "ATE_REQ\020\203\016\022\033\n\026CID_OTHER_VALIDATE_RSP\020\204\016\022"
  "#\n\036CID_OTHER_GET_DEVICE_TOKEN_REQ\020\205\016\022#\n\036"
  "CID_OTHER_GET_DEVICE_TOKEN_RSP\020\206\016\022\027\n\022CID"
  "_OTHER_ROLE_SET\020\207\016\022\037\n\032CID_OTHER_ONLINE_U"
  "SER_INFO\020\210\016\022\034\n\027CID_OTHER_MSG_SERV_INFO\020\211"
  "\016\022!\n\034CID_OTHER_USER_STATUS_UPDATE\020\212\016\022\036\n\031"
  "CID_OTHER_USER_CNT_UPDATE\020\213\016\022\037\n\032CID_OTHE"
  "R_SERVER_KICK_USER\020\215\016\022\"\n\035CID_OTHER_LOGIN"
  "_STATUS_NOTIFY\020\216\016\022\037\n\032CID_OTHER_PUSH_TO_U"
  "SER_REQ\020\217\016\022\037\n\032CID_OTHER_PUSH_TO_USER_RSP"
  "\020\220\016\022\035\n\030CID_OTHER_GET_SHIELD_REQ\020\221\016\022\035\n\030CI"
  "D_OTHER_GET_SHIELD_RSP\020\222\016\022 \n\033CID_OTHER_F"
  "ILE_TRANSFER_REQ\020\261\016\022 \n\033CID_OTHER_FILE_TR"
  "ANSFER_RSP\020\262\016\022!\n\034CID_OTHER_FILE_SERVER_I"
  "P_REQ\020\263\016\022!\n\034CID_OTHER_FILE_SERVER_IP_RSP"
  "\020\264\016*\227\002\n\nResultType\022\026\n\022REFUSE_REASON_NONE"
  "\020\000\022\037\n\033REFUSE_REASON_NO_MSG_SERVER\020\001\022!\n\035R"
  "EFUSE_REASON_MSG_SERVER_FULL\020\002\022\036\n\032REFUSE"
  "_REASON_NO_DB_SERVER\020\003\022!\n\035REFUSE_REASON_"
  "NO_LOGIN_SERVER\020\004\022!\n\035REFUSE_REASON_NO_RO"
  "UTE_SERVER\020\005\022$\n REFUSE_REASON_DB_VALIDAT"
  "E_FAILED\020\006\022!\n\035REFUSE_REASON_VERSION_TOO_"
  "OLD\020\007*M\n\016KickReasonType\022\036\n\032KICK_REASON_D"
  "UPLICATE_USER\020\001\022\033\n\027KICK_REASON_MOBILE_KI"
  "CK\020\002*2\n\016OnlineListType\022 \n\034ONLINE_LIST_TY"
  "PE_FRIEND_LIST\020\001*V\n\014UserStatType\022\026\n\022USER"
  "_STATUS_ONLINE\020\001\022\027\n\023USER_STATUS_OFFLINE\020"
  "\002\022\025\n\021USER_STATUS_LEAVE\020\003*>\n\013SessionType\022"
  "\027\n\023SESSION_TYPE_SINGLE\020\001\022\026\n\022SESSION_TYPE"
  "_GROUP\020\002*q\n\007MsgType\022\030\n\024MSG_TYPE_SINGLE_T"
  "EXT\020\001\022\031\n\025MSG_TYPE_SINGLE_AUDIO\020\002\022\027\n\023MSG_"
  "TYPE_GROUP_TEXT\020\021\022\030\n\024MSG_TYPE_GROUP_AUDI"
  "O\020\022*h\n\nClientType\022\027\n\023CLIENT_TYPE_WINDOWS"
  "\020\001\022\023\n\017CLIENT_TYPE_MAC\020\002\022\023\n\017CLIENT_TYPE_I"
  "OS\020\021\022\027\n\023CLIENT_TYPE_ANDROID\020\022*6\n\tGroupTy"
  "pe\022\025\n\021GROUP_TYPE_NORMAL\020\001\022\022\n\016GROUP_TYPE_"
  "TMP\020\002*G\n\017GroupModifyType\022\031\n\025GROUP_MODIFY"
  "_TYPE_ADD\020\001\022\031\n\025GROUP_MODIFY_TYPE_DEL\020\002*\?"
  "\n\020TransferFileType\022\024\n\020FILE_TYPE_ONLINE\020\001"
  "\022\025\n\021FILE_TYPE_OFFLINE\020\002*s\n\017ClientFileSta"
  "te\022\032\n\026CLIENT_FILE_PEER_READY\020\000\022\026\n\022CLIENT"
  "_FILE_CANCEL\020\001\022\026\n\022CLIENT_FILE_REFUSE\020\002\022\024"
  "\n\020CLIENT_FILE_DONE\020\003*\200\001\n\016ClientFileRole\022"
  "\032\n\026CLIENT_REALTIME_SENDER\020\001\022\032\n\026CLIENT_RE"
  "ALTIME_RECVER\020\002\022\031\n\025CLIENT_OFFLINE_UPLOAD"
  "\020\003\022\033\n\027CLIENT_OFFLINE_DOWNLOAD\020\004*\341\004\n\017File"
  "ServerError\022\030\n\024FILE_SERVER_ERRNO_OK\020\000\022*\n"
  "&FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR\020"
  "\001\022\'\n#FILE_SERVER_ERRNO_CREATE_TASK_ERROR"
  "\020\002\022)\n%FILE_SERVER_ERRNO_LOGIN_INVALID_TO"
  "KEN\020\003\022+\n\'FILE_SERVER_ERRNO_INVALID_USER_"
  "FOR_TASK\020\004\0224\n0FILE_SERVER_ERRNO_PULL_DAT"
  "A_WITH_INVALID_TASK_ID\020\005\022-\n)FILE_SERVER_"
  "ERRNO_PULL_DATA_ILLIEAGE_USER\020\006\022+\n\'FILE_"
  "SERVER_ERRNO_PULL_DATA_MKDIR_ERROR\020\007\022/\n+"
  "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ER"
  "ROR\020\010\0226\n2FILE_SERVER_ERRNO_PULL_DATA_REA"
  "D_FILE_HEADER_ERROR\020\t\022/\n+FILE_SERVER_ERR"
  "NO_PULL_DATA_ALLOC_MEM_ERROR\020\n\0221\n-FILE_S"
  "ERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR\020"
  "\013\022(\n$FILE_SERVER_ERRNO_PULL_DATA_FINISHE"
  "D\020\014*E\n\021SessionStatusType\022\025\n\021SESSION_STAT"
  "US_OK\020\000\022\031\n\025SESSION_STATUS_DELETE\020\001*B\n\024De"
  "partmentStatusType\022\022\n\016DEPT_STATUS_OK\020\000\022\026"
  "\n\022DEPT_STATUS_DELETE\020\001B\031\n\027com.mogujie.tt"
  ".protobuf"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_IM_2eBaseDefine_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IM_2eBaseDefine_2eproto = {
  false, false, 7529, descriptor_table_protodef_IM_2eBaseDefine_2eproto, "IM.BaseDefine.proto", 
  &descriptor_table_IM_2eBaseDefine_2eproto_once, nullptr, 0, 15,
  schemas, file_default_instances, TableStruct_IM_2eBaseDefine_2eproto::offsets,
  file_level_metadata_IM_2eBaseDefine_2eproto, file_level_enum_descriptors_IM_2eBaseDefine_2eproto, file_level_service_descriptors_IM_2eBaseDefine_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_IM_2eBaseDefine_2eproto_getter() {
  return &descriptor_table_IM_2eBaseDefine_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_IM_2eBaseDefine_2eproto(&descriptor_table_IM_2eBaseDefine_2eproto);
namespace IM {
namespace BaseDefine {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[0];
}
bool ServiceID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[1];
}
bool LoginCmdID_IsValid(int value) {
  switch (value) {
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
    case 268:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BuddyListCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[2];
}
bool BuddyListCmdID_IsValid(int value) {
  switch (value) {
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[3];
}
bool MessageCmdID_IsValid(int value) {
  switch (value) {
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[4];
}
bool GroupCmdID_IsValid(int value) {
  switch (value) {
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[5];
}
bool FileCmdID_IsValid(int value) {
  switch (value) {
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwitchServiceCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[6];
}
bool SwitchServiceCmdID_IsValid(int value) {
  switch (value) {
    case 1537:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OtherCmdID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[7];
}
bool OtherCmdID_IsValid(int value) {
  switch (value) {
    case 1793:
    case 1794:
    case 1795:
    case 1796:
    case 1797:
    case 1798:
    case 1799:
    case 1800:
    case 1801:
    case 1802:
    case 1803:
    case 1805:
    case 1806:
    case 1807:
    case 1808:
    case 1809:
    case 1810:
    case 1841:
    case 1842:
    case 1843:
    case 1844:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[8];
}
bool ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KickReasonType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[9];
}
bool KickReasonType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OnlineListType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[10];
}
bool OnlineListType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[11];
}
bool UserStatType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[12];
}
bool SessionType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[13];
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[14];
}
bool ClientType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[15];
}
bool GroupType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupModifyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[16];
}
bool GroupModifyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferFileType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[17];
}
bool TransferFileType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientFileState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[18];
}
bool ClientFileState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientFileRole_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[19];
}
bool ClientFileRole_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileServerError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[20];
}
bool FileServerError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionStatusType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[21];
}
bool SessionStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DepartmentStatusType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IM_2eBaseDefine_2eproto);
  return file_level_enum_descriptors_IM_2eBaseDefine_2eproto[22];
}
bool DepartmentStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class IpAddr::_Internal {
 public:
  using HasBits = decltype(std::declval<IpAddr>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IpAddr::IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.IpAddr)
}
IpAddr::IpAddr(const IpAddr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IpAddr)
}

inline void IpAddr::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0u;
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IpAddr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IpAddr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IpAddr::ArenaDtor(void* object) {
  IpAddr* _this = reinterpret_cast< IpAddr* >(object);
  (void)_this;
}
void IpAddr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpAddr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpAddr::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_.ClearNonDefaultToEmpty();
  }
  port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IpAddr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.IpAddr.ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpAddr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.IpAddr.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required uint32 port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.IpAddr)
  return target;
}

size_t IpAddr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_port()) {
    // required uint32 port = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return total_size;
}
size_t IpAddr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required uint32 port = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IpAddr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IpAddr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IpAddr::GetClassData() const { return &_class_data_; }

void IpAddr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IpAddr *>(to)->MergeFrom(
      static_cast<const IpAddr &>(from));
}


void IpAddr::MergeFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.IpAddr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      port_ = from.port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IpAddr::CopyFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.IpAddr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IpAddr::InternalSwap(IpAddr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
  swap(port_, other->port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IpAddr::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[0]);
}

// ===================================================================

class UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserInfo>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_user_gender(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_user_nick_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_department_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_real_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_tel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000007bf) ^ 0x000007bf) != 0;
  }
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_nick_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_nick_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_nick_name()) {
    user_nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_nick_name(), 
      GetArenaForAllocation());
  }
  avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_url(), 
      GetArenaForAllocation());
  }
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  user_real_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_real_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_real_name()) {
    user_real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_real_name(), 
      GetArenaForAllocation());
  }
  user_tel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_tel()) {
    user_tel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_tel(), 
      GetArenaForAllocation());
  }
  user_domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_domain()) {
    user_domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_domain(), 
      GetArenaForAllocation());
  }
  sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sign_info(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserInfo)
}

inline void UserInfo::SharedCtor() {
user_nick_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_nick_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_real_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_real_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_tel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_nick_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  avatar_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_real_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_tel_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sign_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserInfo::ArenaDtor(void* object) {
  UserInfo* _this = reinterpret_cast< UserInfo* >(object);
  (void)_this;
}
void UserInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      user_nick_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      avatar_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_real_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      user_tel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      user_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      sign_info_.ClearNonDefaultToEmpty();
    }
  }
  user_id_ = 0u;
  if (cached_has_bits & 0x00000700u) {
    ::memset(&user_gender_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&user_gender_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 user_gender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_gender(&has_bits);
          user_gender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_nick_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_nick_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.user_nick_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.avatar_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 department_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_department_id(&has_bits);
          department_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string email = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.email");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_real_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_user_real_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.user_real_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_tel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_user_tel();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.user_tel");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_domain = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_user_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.user_domain");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sign_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserInfo.sign_info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 user_gender = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_gender(), target);
  }

  // required string user_nick_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_nick_name().data(), static_cast<int>(this->_internal_user_nick_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_nick_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_nick_name(), target);
  }

  // required string avatar_url = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_avatar_url().data(), static_cast<int>(this->_internal_avatar_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.avatar_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_avatar_url(), target);
  }

  // required uint32 department_id = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_department_id(), target);
  }

  // required string email = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.email");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_email(), target);
  }

  // required string user_real_name = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_real_name().data(), static_cast<int>(this->_internal_user_real_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_real_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_user_real_name(), target);
  }

  // required string user_tel = 8;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_tel().data(), static_cast<int>(this->_internal_user_tel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_tel");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_user_tel(), target);
  }

  // required string user_domain = 9;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_domain().data(), static_cast<int>(this->_internal_user_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_domain");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_user_domain(), target);
  }

  // required uint32 status = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_status(), target);
  }

  // optional string sign_info = 11;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sign_info().data(), static_cast<int>(this->_internal_sign_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserInfo.sign_info");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_sign_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserInfo)
  return target;
}

size_t UserInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (_internal_has_user_nick_name()) {
    // required string user_nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_nick_name());
  }

  if (_internal_has_avatar_url()) {
    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  if (_internal_has_email()) {
    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  if (_internal_has_user_real_name()) {
    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());
  }

  if (_internal_has_user_tel()) {
    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());
  }

  if (_internal_has_user_domain()) {
    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_user_gender()) {
    // required uint32 user_gender = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_gender());
  }

  if (_internal_has_department_id()) {
    // required uint32 department_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());
  }

  if (_internal_has_status()) {
    // required uint32 status = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  return total_size;
}
size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000007bf) ^ 0x000007bf) == 0) {  // All required fields are present.
    // required string user_nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_nick_name());

    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());

    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());

    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());

    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());

    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 user_gender = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_gender());

    // required uint32 department_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());

    // required uint32 status = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string sign_info = 11;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserInfo::GetClassData() const { return &_class_data_; }

void UserInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserInfo *>(to)->MergeFrom(
      static_cast<const UserInfo &>(from));
}


void UserInfo::MergeFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_nick_name(from._internal_user_nick_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_real_name(from._internal_user_real_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_user_tel(from._internal_user_tel());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_user_domain(from._internal_user_domain());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000080u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      user_gender_ = from.user_gender_;
    }
    if (cached_has_bits & 0x00000200u) {
      department_id_ = from.department_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_nick_name_, lhs_arena,
      &other->user_nick_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_url_, lhs_arena,
      &other->avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_real_name_, lhs_arena,
      &other->user_real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_tel_, lhs_arena,
      &other->user_tel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_domain_, lhs_arena,
      &other->user_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sign_info_, lhs_arena,
      &other->sign_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserInfo, status_)
      + sizeof(UserInfo::status_)
      - PROTOBUF_FIELD_OFFSET(UserInfo, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[1]);
}

// ===================================================================

class ContactSessionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactSessionInfo>()._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_session_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

ContactSessionInfo::ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ContactSessionInfo)
}
ContactSessionInfo::ContactSessionInfo(const ContactSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_latest_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_type_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ContactSessionInfo)
}

inline void ContactSessionInfo::SharedCtor() {
latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
session_type_ = 1;
latest_msg_type_ = 1;
}

ContactSessionInfo::~ContactSessionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ContactSessionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ContactSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  latest_msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ContactSessionInfo::ArenaDtor(void* object) {
  ContactSessionInfo* _this = reinterpret_cast< ContactSessionInfo* >(object);
  (void)_this;
}
void ContactSessionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ContactSessionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContactSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
    session_type_ = 1;
    latest_msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContactSessionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionStatusType session_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionStatusType_IsValid(val))) {
            _internal_set_session_status(static_cast<::IM::BaseDefine::SessionStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 updated_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_updated_time(&has_bits);
          updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType latest_msg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required .IM.BaseDefine.SessionStatusType session_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_status(), target);
  }

  // required uint32 updated_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_updated_time(), target);
  }

  // required uint32 latest_msg_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_latest_msg_data(), target);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ContactSessionInfo)
  return target;
}

size_t ContactSessionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_status()) {
    // required .IM.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_status());
  }

  if (_internal_has_updated_time()) {
    // required uint32 updated_time = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .IM.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t ContactSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .IM.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_status());

    // required uint32 updated_time = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());

    // required uint32 latest_msg_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .IM.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContactSessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContactSessionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContactSessionInfo::GetClassData() const { return &_class_data_; }

void ContactSessionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContactSessionInfo *>(to)->MergeFrom(
      static_cast<const ContactSessionInfo &>(from));
}


void ContactSessionInfo::MergeFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ContactSessionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      session_status_ = from.session_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      updated_time_ = from.updated_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      latest_msg_id_ = from.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      latest_msg_from_user_id_ = from.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      session_type_ = from.session_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      latest_msg_type_ = from.latest_msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContactSessionInfo::CopyFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ContactSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactSessionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ContactSessionInfo::InternalSwap(ContactSessionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &latest_msg_data_, lhs_arena,
      &other->latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContactSessionInfo, latest_msg_from_user_id_)
      + sizeof(ContactSessionInfo::latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(ContactSessionInfo, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
  swap(session_type_, other->session_type_);
  swap(latest_msg_type_, other->latest_msg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContactSessionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[2]);
}

// ===================================================================

class UserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<UserStat>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserStat::UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserStat)
}
UserStat::UserStat(const UserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserStat)
}

inline void UserStat::SharedCtor() {
user_id_ = 0u;
status_ = 1;
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStat::ArenaDtor(void* object) {
  UserStat* _this = reinterpret_cast< UserStat* >(object);
  (void)_this;
}
void UserStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    user_id_ = 0u;
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserStat)
  return target;
}

size_t UserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t UserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserStat)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserStat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserStat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserStat::GetClassData() const { return &_class_data_; }

void UserStat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserStat *>(to)->MergeFrom(
      static_cast<const UserStat &>(from));
}


void UserStat::MergeFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserStat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserStat::CopyFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserStat::InternalSwap(UserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_id_, other->user_id_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserStat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[3]);
}

// ===================================================================

class ServerUserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerUserStat>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ServerUserStat::ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ServerUserStat)
}
ServerUserStat::ServerUserStat(const ServerUserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ServerUserStat)
}

inline void ServerUserStat::SharedCtor() {
user_id_ = 0u;
status_ = 1;
client_type_ = 1;
}

ServerUserStat::~ServerUserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ServerUserStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ServerUserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServerUserStat::ArenaDtor(void* object) {
  ServerUserStat* _this = reinterpret_cast< ServerUserStat* >(object);
  (void)_this;
}
void ServerUserStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ServerUserStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServerUserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    user_id_ = 0u;
    status_ = 1;
    client_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerUserStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_client_type(static_cast<::IM::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerUserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_client_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ServerUserStat)
  return target;
}

size_t ServerUserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (_internal_has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_client_type());
  }

  return total_size;
}
size_t ServerUserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerUserStat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServerUserStat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerUserStat::GetClassData() const { return &_class_data_; }

void ServerUserStat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServerUserStat *>(to)->MergeFrom(
      static_cast<const ServerUserStat &>(from));
}


void ServerUserStat::MergeFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ServerUserStat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerUserStat::CopyFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ServerUserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerUserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ServerUserStat::InternalSwap(ServerUserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_id_, other->user_id_);
  swap(status_, other->status_);
  swap(client_type_, other->client_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerUserStat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[4]);
}

// ===================================================================

class UnreadInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UnreadInfo>()._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_unread_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

UnreadInfo::UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UnreadInfo)
}
UnreadInfo::UnreadInfo(const UnreadInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_latest_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_type_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UnreadInfo)
}

inline void UnreadInfo::SharedCtor() {
latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
session_type_ = 1;
latest_msg_type_ = 1;
}

UnreadInfo::~UnreadInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UnreadInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UnreadInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  latest_msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UnreadInfo::ArenaDtor(void* object) {
  UnreadInfo* _this = reinterpret_cast< UnreadInfo* >(object);
  (void)_this;
}
void UnreadInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UnreadInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnreadInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
    session_type_ = 1;
    latest_msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnreadInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 unread_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unread_cnt(&has_bits);
          unread_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType latest_msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnreadInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required uint32 unread_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unread_cnt(), target);
  }

  // required uint32 latest_msg_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_latest_msg_data(), target);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UnreadInfo)
  return target;
}

size_t UnreadInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_unread_cnt()) {
    // required uint32 unread_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .IM.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t UnreadInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required uint32 unread_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());

    // required uint32 latest_msg_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .IM.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnreadInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UnreadInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnreadInfo::GetClassData() const { return &_class_data_; }

void UnreadInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UnreadInfo *>(to)->MergeFrom(
      static_cast<const UnreadInfo &>(from));
}


void UnreadInfo::MergeFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UnreadInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      unread_cnt_ = from.unread_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      latest_msg_id_ = from.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      latest_msg_from_user_id_ = from.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      session_type_ = from.session_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      latest_msg_type_ = from.latest_msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnreadInfo::CopyFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UnreadInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnreadInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UnreadInfo::InternalSwap(UnreadInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &latest_msg_data_, lhs_arena,
      &other->latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnreadInfo, latest_msg_from_user_id_)
      + sizeof(UnreadInfo::latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(UnreadInfo, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
  swap(session_type_, other->session_type_);
  swap(latest_msg_type_, other->latest_msg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnreadInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[5]);
}

// ===================================================================

class MsgInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgInfo>()._has_bits_);
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_create_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

MsgInfo::MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.MsgInfo)
}
MsgInfo::MsgInfo(const MsgInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&msg_id_, &from.msg_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&msg_type_) -
    reinterpret_cast<char*>(&msg_id_)) + sizeof(msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgInfo)
}

inline void MsgInfo::SharedCtor() {
msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&msg_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&create_time_) -
    reinterpret_cast<char*>(&msg_id_)) + sizeof(create_time_));
msg_type_ = 1;
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MsgInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MsgInfo::ArenaDtor(void* object) {
  MsgInfo* _this = reinterpret_cast< MsgInfo* >(object);
  (void)_this;
}
void MsgInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MsgInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MsgInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&msg_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&create_time_) -
        reinterpret_cast<char*>(&msg_id_)) + sizeof(create_time_));
    msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_id(&has_bits);
          msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_from_session_id(&has_bits);
          from_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 create_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_create_time(&has_bits);
          create_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType msg_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 msg_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // required uint32 from_session_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_session_id(), target);
  }

  // required uint32 create_time = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_create_time(), target);
  }

  // required .IM.BaseDefine.MsgType msg_type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_msg_type(), target);
  }

  // required bytes msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.MsgInfo)
  return target;
}

size_t MsgInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (_internal_has_msg_data()) {
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  if (_internal_has_from_session_id()) {
    // required uint32 from_session_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());
  }

  if (_internal_has_create_time()) {
    // required uint32 create_time = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());
  }

  if (_internal_has_msg_type()) {
    // required .IM.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());

    // required uint32 msg_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

    // required uint32 from_session_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());

    // required uint32 create_time = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());

    // required .IM.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MsgInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MsgInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MsgInfo::GetClassData() const { return &_class_data_; }

void MsgInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MsgInfo *>(to)->MergeFrom(
      static_cast<const MsgInfo &>(from));
}


void MsgInfo::MergeFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.MsgInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      msg_id_ = from.msg_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_session_id_ = from.from_session_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      create_time_ = from.create_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      msg_type_ = from.msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.MsgInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MsgInfo::InternalSwap(MsgInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &msg_data_, lhs_arena,
      &other->msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfo, create_time_)
      + sizeof(MsgInfo::create_time_)
      - PROTOBUF_FIELD_OFFSET(MsgInfo, msg_id_)>(
          reinterpret_cast<char*>(&msg_id_),
          reinterpret_cast<char*>(&other->msg_id_));
  swap(msg_type_, other->msg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[6]);
}

// ===================================================================

class GroupVersionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupVersionInfo>()._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupVersionInfo::GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupVersionInfo)
}
GroupVersionInfo::GroupVersionInfo(const GroupVersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&group_id_, &from.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupVersionInfo)
}

inline void GroupVersionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&group_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
}

GroupVersionInfo::~GroupVersionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupVersionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GroupVersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupVersionInfo::ArenaDtor(void* object) {
  GroupVersionInfo* _this = reinterpret_cast< GroupVersionInfo* >(object);
  (void)_this;
}
void GroupVersionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GroupVersionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GroupVersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupVersionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupVersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupVersionInfo)
  return target;
}

size_t GroupVersionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t GroupVersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupVersionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GroupVersionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupVersionInfo::GetClassData() const { return &_class_data_; }

void GroupVersionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GroupVersionInfo *>(to)->MergeFrom(
      static_cast<const GroupVersionInfo &>(from));
}


void GroupVersionInfo::MergeFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupVersionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupVersionInfo::CopyFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupVersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupVersionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GroupVersionInfo::InternalSwap(GroupVersionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupVersionInfo, version_)
      + sizeof(GroupVersionInfo::version_)
      - PROTOBUF_FIELD_OFFSET(GroupVersionInfo, group_id_)>(
          reinterpret_cast<char*>(&group_id_),
          reinterpret_cast<char*>(&other->group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupVersionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[7]);
}

// ===================================================================

class GroupInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupInfo>()._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_creator_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

GroupInfo::GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  group_member_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupInfo)
}
GroupInfo::GroupInfo(const GroupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      group_member_list_(from.group_member_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  group_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_name()) {
    group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_group_name(), 
      GetArenaForAllocation());
  }
  group_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_avatar()) {
    group_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_group_avatar(), 
      GetArenaForAllocation());
  }
  ::memcpy(&group_id_, &from.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_type_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(group_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupInfo)
}

inline void GroupInfo::SharedCtor() {
group_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
group_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&group_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(shield_status_));
group_type_ = 1;
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GroupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  group_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_avatar_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GroupInfo::ArenaDtor(void* object) {
  GroupInfo* _this = reinterpret_cast< GroupInfo* >(object);
  (void)_this;
}
void GroupInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GroupInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  group_member_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      group_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      group_avatar_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&group_id_)) + sizeof(shield_status_));
    group_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_group_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.GroupInfo.group_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_avatar = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_group_avatar();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.GroupInfo.group_avatar");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_creator_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_group_creator_id(&has_bits);
          group_creator_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.GroupType group_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::IM::BaseDefine::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 group_member_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_group_member_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  // required string group_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_group_name().data(), static_cast<int>(this->_internal_group_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.GroupInfo.group_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_group_name(), target);
  }

  // required string group_avatar = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_group_avatar().data(), static_cast<int>(this->_internal_group_avatar().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.GroupInfo.group_avatar");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_group_avatar(), target);
  }

  // required uint32 group_creator_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_group_creator_id(), target);
  }

  // required .IM.BaseDefine.GroupType group_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_group_type(), target);
  }

  // required uint32 shield_status = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_shield_status(), target);
  }

  // repeated uint32 group_member_list = 8;
  for (int i = 0, n = this->_internal_group_member_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_group_member_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupInfo)
  return target;
}

size_t GroupInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (_internal_has_group_name()) {
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());
  }

  if (_internal_has_group_avatar()) {
    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  if (_internal_has_group_creator_id()) {
    // required uint32 group_creator_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  if (_internal_has_group_type()) {
    // required .IM.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  return total_size;
}
size_t GroupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());

    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());

    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

    // required uint32 group_creator_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());

    // required uint32 shield_status = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

    // required .IM.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_group_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 group_member_list = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->group_member_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_group_member_list_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GroupInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupInfo::GetClassData() const { return &_class_data_; }

void GroupInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GroupInfo *>(to)->MergeFrom(
      static_cast<const GroupInfo &>(from));
}


void GroupInfo::MergeFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  group_member_list_.MergeFrom(from.group_member_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_group_name(from._internal_group_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_group_avatar(from._internal_group_avatar());
    }
    if (cached_has_bits & 0x00000004u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      group_creator_id_ = from.group_creator_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      shield_status_ = from.shield_status_;
    }
    if (cached_has_bits & 0x00000040u) {
      group_type_ = from.group_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GroupInfo::InternalSwap(GroupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  group_member_list_.InternalSwap(&other->group_member_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &group_name_, lhs_arena,
      &other->group_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &group_avatar_, lhs_arena,
      &other->group_avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupInfo, shield_status_)
      + sizeof(GroupInfo::shield_status_)
      - PROTOBUF_FIELD_OFFSET(GroupInfo, group_id_)>(
          reinterpret_cast<char*>(&group_id_),
          reinterpret_cast<char*>(&other->group_id_));
  swap(group_type_, other->group_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[8]);
}

// ===================================================================

class UserTokenInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserTokenInfo>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_push_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_push_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

UserTokenInfo::UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserTokenInfo)
}
UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&user_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(user_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserTokenInfo)
}

inline void UserTokenInfo::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&push_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(push_type_));
user_type_ = 1;
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserTokenInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserTokenInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserTokenInfo::ArenaDtor(void* object) {
  UserTokenInfo* _this = reinterpret_cast< UserTokenInfo* >(object);
  (void)_this;
}
void UserTokenInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserTokenInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserTokenInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&push_type_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(push_type_));
    user_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserTokenInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.ClientType user_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_user_type(static_cast<::IM::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.UserTokenInfo.token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_push_count(&has_bits);
          push_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_push_type(&has_bits);
          push_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserTokenInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.ClientType user_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_type(), target);
  }

  // required string token = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.UserTokenInfo.token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_token(), target);
  }

  // required uint32 push_count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_push_count(), target);
  }

  // required uint32 push_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_push_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserTokenInfo)
  return target;
}

size_t UserTokenInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (_internal_has_token()) {
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_push_count()) {
    // required uint32 push_count = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());
  }

  if (_internal_has_push_type()) {
    // required uint32 push_type = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());
  }

  if (_internal_has_user_type()) {
    // required .IM.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_user_type());
  }

  return total_size;
}
size_t UserTokenInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 push_count = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());

    // required uint32 push_type = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());

    // required .IM.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_user_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserTokenInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserTokenInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserTokenInfo::GetClassData() const { return &_class_data_; }

void UserTokenInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserTokenInfo *>(to)->MergeFrom(
      static_cast<const UserTokenInfo &>(from));
}


void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserTokenInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      push_count_ = from.push_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      push_type_ = from.push_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      user_type_ = from.user_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserTokenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserTokenInfo::InternalSwap(UserTokenInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserTokenInfo, push_type_)
      + sizeof(UserTokenInfo::push_type_)
      - PROTOBUF_FIELD_OFFSET(UserTokenInfo, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
  swap(user_type_, other->user_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserTokenInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[9]);
}

// ===================================================================

class PushResult::_Internal {
 public:
  using HasBits = decltype(std::declval<PushResult>()._has_bits_);
  static void set_has_user_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PushResult::PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.PushResult)
}
PushResult::PushResult(const PushResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_token()) {
    user_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_token(), 
      GetArenaForAllocation());
  }
  result_code_ = from.result_code_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushResult)
}

inline void PushResult::SharedCtor() {
user_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
result_code_ = 0u;
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PushResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PushResult::ArenaDtor(void* object) {
  PushResult* _this = reinterpret_cast< PushResult* >(object);
  (void)_this;
}
void PushResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PushResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PushResult::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_token_.ClearNonDefaultToEmpty();
  }
  result_code_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PushResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string user_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.PushResult.user_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string user_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_token().data(), static_cast<int>(this->_internal_user_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.PushResult.user_token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_token(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.PushResult)
  return target;
}

size_t PushResult::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.PushResult)
  size_t total_size = 0;

  if (_internal_has_user_token()) {
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  return total_size;
}
size_t PushResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.PushResult)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());

    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PushResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PushResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PushResult::GetClassData() const { return &_class_data_; }

void PushResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PushResult *>(to)->MergeFrom(
      static_cast<const PushResult &>(from));
}


void PushResult::MergeFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.PushResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_token(from._internal_user_token());
    }
    if (cached_has_bits & 0x00000002u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PushResult::CopyFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.PushResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PushResult::InternalSwap(PushResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_token_, lhs_arena,
      &other->user_token_, rhs_arena
  );
  swap(result_code_, other->result_code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PushResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[10]);
}

// ===================================================================

class ShieldStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShieldStatus>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ShieldStatus::ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ShieldStatus)
}
ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ShieldStatus)
}

inline void ShieldStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ShieldStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShieldStatus::ArenaDtor(void* object) {
  ShieldStatus* _this = reinterpret_cast< ShieldStatus* >(object);
  (void)_this;
}
void ShieldStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ShieldStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShieldStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // required uint32 shield_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ShieldStatus)
  return target;
}

size_t ShieldStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t ShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 group_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 shield_status = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShieldStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShieldStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShieldStatus::GetClassData() const { return &_class_data_; }

void ShieldStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShieldStatus *>(to)->MergeFrom(
      static_cast<const ShieldStatus &>(from));
}


void ShieldStatus::MergeFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ShieldStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      shield_status_ = from.shield_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ShieldStatus::InternalSwap(ShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShieldStatus, shield_status_)
      + sizeof(ShieldStatus::shield_status_)
      - PROTOBUF_FIELD_OFFSET(ShieldStatus, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShieldStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[11]);
}

// ===================================================================

class OfflineFileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OfflineFileInfo>()._has_bits_);
  static void set_has_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_task_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

OfflineFileInfo::OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.OfflineFileInfo)
}
OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  task_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    task_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_task_id()) {
    task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_task_id(), 
      GetArenaForAllocation());
  }
  file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_name()) {
    file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&from_user_id_, &from.from_user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&file_size_) -
    reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineFileInfo)
}

inline void OfflineFileInfo::SharedCtor() {
task_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  task_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&from_user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&file_size_) -
    reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineFileInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OfflineFileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  task_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void OfflineFileInfo::ArenaDtor(void* object) {
  OfflineFileInfo* _this = reinterpret_cast< OfflineFileInfo* >(object);
  (void)_this;
}
void OfflineFileInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OfflineFileInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OfflineFileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      task_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      file_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&from_user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&file_size_) -
        reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OfflineFileInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 from_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_from_user_id(&has_bits);
          from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_task_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.OfflineFileInfo.task_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_file_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.OfflineFileInfo.file_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 file_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_file_size(&has_bits);
          file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 from_user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_from_user_id(), target);
  }

  // required string task_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_task_id().data(), static_cast<int>(this->_internal_task_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.OfflineFileInfo.task_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_task_id(), target);
  }

  // required string file_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_file_name().data(), static_cast<int>(this->_internal_file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.OfflineFileInfo.file_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_file_name(), target);
  }

  // required uint32 file_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_file_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.OfflineFileInfo)
  return target;
}

size_t OfflineFileInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (_internal_has_task_id()) {
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());
  }

  if (_internal_has_file_name()) {
    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());
  }

  if (_internal_has_from_user_id()) {
    // required uint32 from_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());
  }

  if (_internal_has_file_size()) {
    // required uint32 file_size = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());
  }

  return total_size;
}
size_t OfflineFileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());

    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());

    // required uint32 from_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());

    // required uint32 file_size = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OfflineFileInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OfflineFileInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OfflineFileInfo::GetClassData() const { return &_class_data_; }

void OfflineFileInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OfflineFileInfo *>(to)->MergeFrom(
      static_cast<const OfflineFileInfo &>(from));
}


void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.OfflineFileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_task_id(from._internal_task_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000004u) {
      from_user_id_ = from.from_user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      file_size_ = from.file_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.OfflineFileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void OfflineFileInfo::InternalSwap(OfflineFileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &task_id_, lhs_arena,
      &other->task_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_name_, lhs_arena,
      &other->file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFileInfo, file_size_)
      + sizeof(OfflineFileInfo::file_size_)
      - PROTOBUF_FIELD_OFFSET(OfflineFileInfo, from_user_id_)>(
          reinterpret_cast<char*>(&from_user_id_),
          reinterpret_cast<char*>(&other->from_user_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OfflineFileInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[12]);
}

// ===================================================================

class DepartInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DepartInfo>()._has_bits_);
  static void set_has_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dept_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dept_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

DepartInfo::DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.DepartInfo)
}
DepartInfo::DepartInfo(const DepartInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  dept_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dept_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dept_name()) {
    dept_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_dept_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&dept_id_, &from.dept_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&dept_status_) -
    reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.DepartInfo)
}

inline void DepartInfo::SharedCtor() {
dept_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dept_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dept_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dept_status_) -
    reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
}

DepartInfo::~DepartInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.DepartInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DepartInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  dept_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DepartInfo::ArenaDtor(void* object) {
  DepartInfo* _this = reinterpret_cast< DepartInfo* >(object);
  (void)_this;
}
void DepartInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DepartInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DepartInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    dept_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&dept_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dept_status_) -
        reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DepartInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 dept_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dept_id(&has_bits);
          dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string dept_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dept_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "IM.BaseDefine.DepartInfo.dept_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 parent_dept_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_parent_dept_id(&has_bits);
          parent_dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::DepartmentStatusType_IsValid(val))) {
            _internal_set_dept_status(static_cast<::IM::BaseDefine::DepartmentStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DepartInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 dept_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dept_id(), target);
  }

  // required uint32 priority = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  // required string dept_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dept_name().data(), static_cast<int>(this->_internal_dept_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "IM.BaseDefine.DepartInfo.dept_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dept_name(), target);
  }

  // required uint32 parent_dept_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_parent_dept_id(), target);
  }

  // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_dept_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.DepartInfo)
  return target;
}

size_t DepartInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (_internal_has_dept_name()) {
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());
  }

  if (_internal_has_dept_id()) {
    // required uint32 dept_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());
  }

  if (_internal_has_priority()) {
    // required uint32 priority = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  if (_internal_has_parent_dept_id()) {
    // required uint32 parent_dept_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());
  }

  if (_internal_has_dept_status()) {
    // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dept_status());
  }

  return total_size;
}
size_t DepartInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());

    // required uint32 dept_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());

    // required uint32 priority = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());

    // required uint32 parent_dept_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());

    // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dept_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DepartInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DepartInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DepartInfo::GetClassData() const { return &_class_data_; }

void DepartInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DepartInfo *>(to)->MergeFrom(
      static_cast<const DepartInfo &>(from));
}


void DepartInfo::MergeFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.DepartInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dept_name(from._internal_dept_name());
    }
    if (cached_has_bits & 0x00000002u) {
      dept_id_ = from.dept_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      parent_dept_id_ = from.parent_dept_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      dept_status_ = from.dept_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DepartInfo::CopyFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.DepartInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepartInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DepartInfo::InternalSwap(DepartInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &dept_name_, lhs_arena,
      &other->dept_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DepartInfo, dept_status_)
      + sizeof(DepartInfo::dept_status_)
      - PROTOBUF_FIELD_OFFSET(DepartInfo, dept_id_)>(
          reinterpret_cast<char*>(&dept_id_),
          reinterpret_cast<char*>(&other->dept_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DepartInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[13]);
}

// ===================================================================

class PushShieldStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PushShieldStatus>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PushShieldStatus::PushShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.PushShieldStatus)
}
PushShieldStatus::PushShieldStatus(const PushShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushShieldStatus)
}

inline void PushShieldStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
}

PushShieldStatus::~PushShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushShieldStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PushShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PushShieldStatus::ArenaDtor(void* object) {
  PushShieldStatus* _this = reinterpret_cast< PushShieldStatus* >(object);
  (void)_this;
}
void PushShieldStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PushShieldStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PushShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.PushShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PushShieldStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.PushShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 shield_status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.PushShieldStatus)
  return target;
}

size_t PushShieldStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.PushShieldStatus)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t PushShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.PushShieldStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 shield_status = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PushShieldStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PushShieldStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PushShieldStatus::GetClassData() const { return &_class_data_; }

void PushShieldStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PushShieldStatus *>(to)->MergeFrom(
      static_cast<const PushShieldStatus &>(from));
}


void PushShieldStatus::MergeFrom(const PushShieldStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.PushShieldStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      shield_status_ = from.shield_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PushShieldStatus::CopyFrom(const PushShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.PushShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushShieldStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PushShieldStatus::InternalSwap(PushShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PushShieldStatus, shield_status_)
      + sizeof(PushShieldStatus::shield_status_)
      - PROTOBUF_FIELD_OFFSET(PushShieldStatus, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PushShieldStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_IM_2eBaseDefine_2eproto_getter, &descriptor_table_IM_2eBaseDefine_2eproto_once,
      file_level_metadata_IM_2eBaseDefine_2eproto[14]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace BaseDefine
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::IpAddr* Arena::CreateMaybeMessage< ::IM::BaseDefine::IpAddr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::IpAddr >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ContactSessionInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::ContactSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ContactSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserStat* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ServerUserStat* Arena::CreateMaybeMessage< ::IM::BaseDefine::ServerUserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ServerUserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UnreadInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UnreadInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UnreadInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::MsgInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::MsgInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::MsgInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupVersionInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupVersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupVersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserTokenInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserTokenInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserTokenInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::PushResult* Arena::CreateMaybeMessage< ::IM::BaseDefine::PushResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::PushResult >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ShieldStatus* Arena::CreateMaybeMessage< ::IM::BaseDefine::ShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ShieldStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::OfflineFileInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::OfflineFileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::OfflineFileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::DepartInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::DepartInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::DepartInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::PushShieldStatus* Arena::CreateMaybeMessage< ::IM::BaseDefine::PushShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::PushShieldStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
